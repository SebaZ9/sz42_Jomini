using Lidgren.Network;
using ProtoMessageClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading.Tasks;

namespace JominiServer
{
    public class LogInManager
    {
        /// <summary>
        /// Dictionary mapping usernames to session salts, used to ensure each user gets their own salt once connected
        /// </summary>
        private static Dictionary<string, byte[]> SessionSalts;
        /// <summary>
        /// Dictionary mapping player username to password hash and salt- for use during testing,
        /// should use database for final. First byte array is hash, second is salt
        /// </summary>
        public static Dictionary<string, Tuple<byte[], byte[]>> Users;
        /// <summary>
        /// The server's own X509 certificate, which clients can verify
        /// </summary>
        public X509Certificate2 ServerCert;
        /// <summary>
        /// Performs RSA en/decryption
        /// </summary>
        private RSACryptoServiceProvider RSAProvider;

        public LogInManager(string path)
        {
            SessionSalts = new Dictionary<string, byte[]>();
            Users = new Dictionary<string, Tuple<byte[], byte[]>>();
            InitialiseCertificateAndRSA(path);
        }

        /// <summary>
        /// Computes the hash of a salt appended to source byte array
        /// </summary>
        /// <param name="toHash">bytes to be hashed</param>
        /// <param name="salt">salt</param>
        /// <returns>computed hash</returns>
        public byte[] ComputeHash(byte[] toHash, byte[] salt)
        {
            byte[] fullHash = new byte[toHash.Length + salt.Length];
            toHash.CopyTo(fullHash, 0);
            salt.CopyTo(fullHash, toHash.Length);
            return SHA256.HashData(fullHash);
        }

        /// <summary>
        /// Store a new user in the database
        /// </summary>
        /// <param name="username">Username</param>
        /// <param name="pass">Password. Note this isn't stored, only the hash and salt are</param>
        public void StoreNewUser(string username, string pass)
        {
            byte[] passBytes = Encoding.UTF8.GetBytes(pass);
            byte[] salt = RandomNumberGenerator.GetBytes(32);
            byte[] computedHash = ComputeHash(passBytes, salt);
            Users.Add(username, new Tuple<byte[], byte[]>(computedHash, salt));
        }

        /// <summary>
        /// Retrieve password hash from database
        /// </summary>
        /// <param name="username">Username</param>
        /// <returns>password hash</returns>
        public byte[]? GetPasswordHash(string username)
        {
            Tuple<byte[], byte[]> hashNsalt;
            return Users.TryGetValue(username, out hashNsalt) ? hashNsalt.Item1 : null;
        }

        /// <summary>
        /// Retrieve salt used when hashing password from database
        /// </summary>
        /// <param name="username">username</param>
        /// <returns>salt</returns>
        public byte[]? GetUserSalt(string username)
        {
            Tuple<byte[], byte[]> hashNsalt;
            return Users.TryGetValue(username, out hashNsalt) ? hashNsalt.Item2 : null;
        }

        /// <summary>
        /// Verify the identity of a user by computing and comparing password hashes
        /// </summary>
        /// <param name="username">username</param>
        /// <param name="userhash">hash generated by client</param>
        /// <returns></returns>
        public bool VerifyUser(string username, byte[] userhash)
        {
            if (userhash == null)
            {
                return false;
            }
            byte[] sessionSalt;
            if (!SessionSalts.TryGetValue(username, out sessionSalt))
            {
                return false;
            }
            byte[] passwordHash = ComputeHash(GetPasswordHash(username), sessionSalt);
            return userhash.SequenceEqual(passwordHash);
        }

        /// <summary>
        /// Determines whether or not to accept the connection based on whether a user's username is recognised, and constructs a ProtoLogIn containing session salt
        /// </summary>
        /// <param name="client">Client who is connecting</param>
        /// <param name="text">Challenge text from which to create a signature</param>
        /// <param name="response">Response message</param>
        /// <returns>Boolean indicating whether connection was accepted</returns>
        public bool AcceptConnection(Client client, string text, out ProtoLogIn? response)
        {
            byte[] sessionSalt = RandomNumberGenerator.GetBytes(32);
            byte[] userSalt = GetUserSalt(client.Username);
            if (userSalt == null)
            {
                response = null;
                return false;
            }
            response = new ProtoLogIn { SessionSalt = sessionSalt };
            if (!SessionSalts.ContainsKey(client.Username))
            {
                SessionSalts.Add(client.Username, sessionSalt);
            }
            else
            {
                SessionSalts[client.Username] = sessionSalt;
            }
            response.UserSalt = userSalt;
            response.ActionType = Actions.LogIn;
            if (ServerCert != null)
            {
                response.Certificate = ServerCert.GetRawCertData();
            }
            response.Signature = Sign(text);
            return true;
        }

        /// <summary>
        /// Sign a certificate
        /// Note that now we are allowing certificates to be unsigned for purpose of testing
        /// </summary>
        /// <author> Alejandro Campos Magencio 2008</author>
        /// <param name="text">String to sign</param>
        /// <returns></returns>
        private byte[] Sign(string text)
        {
            UnicodeEncoding encoding = new UnicodeEncoding();

            byte[] data = encoding.GetBytes(text);
            byte[] hash = SHA256.HashData(data);
            
            return RSAProvider.SignHash(hash, CryptoConfig.MapNameToOID("SHA256"));
        }

        /// <summary>
        /// Initialise the server certificate, and initialise the RSACryptoServiceProvider to use the server's public and private keys
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        public bool InitialiseCertificateAndRSA(string path)
        {
            try
            {
                path = Path.Combine(path, "ServerCert.pfx");
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                return false;
            }
            ServerCert = new X509Certificate2(path, "zip1020", X509KeyStorageFlags.Exportable);
            X509Chain chain = new X509Chain
            {
                ChainPolicy =
                {
                    RevocationFlag = X509RevocationFlag.EndCertificateOnly,
                    RevocationMode = X509RevocationMode.NoCheck
                }
            };
            // This song-and-dance is to get SHA256 working for certificate signing
            RSACryptoServiceProvider? rsa2 = ServerCert.PrivateKey as RSACryptoServiceProvider;
            // Create a new RSACryptoServiceProvider
            RSAProvider = new RSACryptoServiceProvider();
            // Export RSA parameters from 'rsa' and import them into 'rsaClear'
            RSAProvider.ImportParameters(rsa2.ExportParameters(true));
            return true;
        }

        /// <summary>
        /// Take a client's log in details, verify them and then choose to either allow the user to log in, or disconnect
        /// </summary>
        /// <param name="login">Log in details</param>
        /// <param name="c">Client who is logging in</param>
        /// <returns>Boolean indicating whether log in was successful</returns>
        public bool ProcessLogIn(ProtoLogIn login, Client c, NetServer server)
        {
            if (!VerifyUser(c.Username, login.UserSalt))
            {
                return false;
            }
            try
            {
                if (login.Key != null)
                {
                    byte[] key = RSAProvider.Decrypt(login.Key, false);
                    // Key must be non-null and long enough

                    if (key == null || key.Length < 5)
                    {
                        return false;
                    }
                    c.EncryptionAlg = new NetAESEncryption(server, key, 0, key.Length);
                }
                else
                {
                    return false;
                }
                ProtoClient clientDetails = new ProtoClient(c);
                clientDetails.ActionType = Actions.LogIn;
                clientDetails.ResponseType = DisplayMessages.LogInSuccess;
                Server.SendViaProto(clientDetails, c.conn, c.alg);
                Globals_Game.RegisterObserver(c);
                return true;
            }
            catch (Exception e)
            {
#if DEBUG
                Console.WriteLine("Failure during decryption: " + e.GetType() + " " + e.Message + ";" + e.StackTrace);
#endif
                return false;
            }
        }

    }
}
